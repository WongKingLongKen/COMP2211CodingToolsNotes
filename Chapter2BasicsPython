List comprehension: concise version of for loop
e.g.
```
num_set = [1, 2, 3, 4, 5]
even_sq_set = [x ** 2 for each_num in num_set if x%2 == 0]
print(sq_set)
```

tuples can be the key of dict but list can't due to its mutability
```
d = {(x, x + 1): x for x in range(10)}  # Valid: tuples as keys
t = (5, 6)
print(d[t])  # Output: 5 (works because tuples are hashable)

# If you try with a list:
d = {[x, x + 1]: x for x in range(10)}  # TypeError: unhashable type 'list'
```

zip(): in case two sets different lengths, depends on the set with fewer items
e.g.
```
set1 = ['boy', 'girl']
set2 = ['yes', 'yesyes']

for gender, reaction in zip(set1, set2):
  print(gender, 'represents', reaction)

# boy represents yes
# girl represents yesyes
```

**parameter name: use it in case we dun know how many keyword arguments are there to pass into the function. The function can get a dict of arguments
```
def print_name_score(**student):
  print("His name is " + student["name"] + " and his score is " + str(student["score"]))

print_name_score(name="Kelvin", score=87)
```

access private instance variable from outside a class: it's just a convention to type the private one as __instance_variable. It doesn't mean we can't access it.
e.g.
```
class Person:
  def __init__(self): # constructor: initialize instance variable
    self.__name = "Ken" # __name: instance variable that belongs to an object
    self.height = height
  def meters_height(self): # meters_height: method that has no value itself
    return self.height / 100

P = Person()
P._Person__name = "Tim"
print(P._Person__name) # output: Tim
```





In Python, for an expression:
 
s[start : stop : step]
 
A negative step size indicates that we are NOT slicing from left to right but from right to left. Hence start index should be larger or equal to the end index. Otherwise, the resulting sequence is empty. Suppose we have an expression:
 
s[::-1]
The default value for “start” is NOT 0, and “end” is NOT len(s), but start = len(s)-1, and end = -1.
Note that the start index is still included, and the end index is still excluded from the slice. Because of that, the default end index is -1 and not 0.
 
For example:
 
A = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(A[:-2:-2])
 
As the step is a negative value, we are slicing from right to left.
Hence, “start” index should be larger or equal to the “end” index.
Default value for “start” is len(A)-1, i.e., 9 – 1 = 8
So, the expression A[:,-2,-2] is equivalent to A[8,-2,-2]
The element at index 8 is 9, and the element at index -2 is excluded.
So, it prints 9.
