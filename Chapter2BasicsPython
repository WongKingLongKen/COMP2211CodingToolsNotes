List comprehension: concise version of for loop
e.g.
```
num_set = [1, 2, 3, 4, 5]
even_sq_set = [x ** 2 for each_num in num_set if x%2 == 0]
print(sq_set)
```

tuples can be the key of dict but list can't due to its mutability
```
d = {(x, x + 1): x for x in range(10)}  # Valid: tuples as keys
t = (5, 6)
print(d[t])  # Output: 5 (works because tuples are hashable)

# If you try with a list:
d = {[x, x + 1]: x for x in range(10)}  # TypeError: unhashable type 'list'
```

zip(): in case two sets different lengths, depends on the set with fewer items
e.g.
```
set1 = ['boy', 'girl']
set2 = ['yes', 'yesyes']

for gender, reaction in zip(set1, set2):
  print(gender, 'represents', reaction)

# boy represents yes
# girl represents yesyes
```

**parameter name: use it in case we dun know how many keyword arguments are there to pass into the function. The function can get a dict of arguments
```
def print_name_score(**student):
  print("His name is " + student["name"] + " and his score is " + student["score"])

print_name_score(name = "Kelvin", score = 87)
```

access private instance variable from outside a class: it's just a convention to type the private one as __instance_variable. It doesn't mean we can't access it.
e.g.
```
class Person:
  def __init__(self): # constructor: initialize instance variable
    self.__name = "Ken" # __name: instance variable that belongs to an object
    self.height = height
  def meters_height(self): # meters_height: method that has no value itself
    return self.height / 100

P = Person()
P._Person__name = "Tim"
print(P._Person__name) # output: Tim
```
