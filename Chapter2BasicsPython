1D array: e.g. [1 2 3] shape: (3,)

View: modify the new variable based on the original one will also change the original one (refer tp copy and view file)
a = np.array([[0, 1], [5, 8]])
b = a[:, :1]
print(a[0, 0]) # 0
b[0, 0] = 100
print(a[0, 0]) # 100

List comprehension: concise version of for loop
e.g.
```
num_set = [1, 2, 3, 4, 5]
even_sq_set = [x ** 2 for each_num in num_set if x%2 == 0]
print(sq_set)
```

tuples can be the key of dict but list can't due to its mutability
```
d = {(x, x + 1): x for x in range(10)}  # Valid: tuples as keys
t = (5, 6)
print(d[t])  # Output: 5 (works because tuples are hashable)

# If you try with a list:
d = {[x, x + 1]: x for x in range(10)}  # TypeError: unhashable type 'list'
```

zip(): in case two sets different lengths, depends on the set with fewer items
e.g.
```
set1 = ['boy', 'girl']
set2 = ['yes', 'yesyes']

for gender, reaction in zip(set1, set2):
  print(gender, 'represents', reaction)

# boy represents yes
# girl represents yesyes
```

**parameter name: use it in case we dun know how many keyword arguments are there to pass into the function. The function can get a dict of arguments
```
def print_name_score(**student):
  print("His name is " + student["name"] + " and his score is " + str(student["score"]))

print_name_score(name="Kelvin", score=87)
```

access private instance variable from outside a class: it's just a convention to type the private one as __instance_variable. It doesn't mean we can't access it.
e.g.
```
class Person:
  def __init__(self, name="Ken", height=180): # constructor: initialize instance variable
    self.__name = name # __name: instance variable that belongs to an object
    self.__height = height
  def meters_height(self): # meters_height: method that has no value itself
    return self.__height / 100
  def print(self):
    print("Name: " + self.__name)
    print("Height: " + self.__height)

P = Person()                                  
P._Person__name = "Tim"
print(P._Person__name) # output: Tim

# Error
tim = Person("Tim", 185)
print("Name: " + self.__name)
print("Height: " + self.height)

# Better way
tim.__name = "Tim"
tim.__height = 185
tim.print()
```
Why tim.__name Fails
Direct Access Attempt:
When you try print(tim.__name), Python looks for an attribute named __name in the instance.

But __name has been renamed to _Person__name due to name mangling.

Result: AttributeError (no __name attribute exists).

Assignment tim.__name = 'Tim':
This does not modify the original private variable (_Person__name). Instead:

A new public attribute __name is created on the instance.

The original _Person__name remains unchanged (as seen in tim.print()).

The best way is to create accessors and mutators:
```
# we need to add those as follows
def get_name(self):
  return self.__name
def get_height(self):
  return self.__height
def set_name(self, name):
  self.__name = name
def set_height(self, height):
  self.__height = height

print("Name: " + tim.get_name())
tim.set_height(185)
```

Class inheritance: define a new class based on existing class
```
class Animal:

    name = ""
    
    def eat(self):
        print("I can eat")

# inherit from Animal
class Dog(Animal):
    
    # override eat() method
    def eat(self):
        
        # call the eat() method of the superclass using super()
        super().eat()
        
        print("I like to eat bones")

# create an object of the subclass
labrador = Dog()

labrador.eat()
```

Tricks with int indexing
e.g.
```
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
b = np.array([0, 2, 1])
print(a[np.arange(3), b]) # [1 6 8]
a[np.arange[3], b] += 10
print(a) 
"""
[[11 2 3]
 [4 5 16]
 [7 18 9]]
"""
```

slicing:
s[start : stop : step]
 
A negative step size indicates that we are NOT slicing from left to right but from right to left. Hence start index should be larger or equal to the end index. 
Otherwise, the resulting sequence is empty. Suppose we have an expression:
 
s[::-1]
The default value for “start” is NOT 0, and “end” is NOT len(s), but start = len(s)-1, and end = -1.
Note that the start index is still included, and the end index is still excluded from the slice. Because of that, the default end index is -1 and not 0.
e.g. 
```
A = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(A[::-1]) # print all
print(A[:-1:]) # print all except 9 (end index) 
print(A[:-1:-1]) # output: [] since it starts from the right and stop immediately
```

For example:
 
A = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(A[:-2:-2]) or print(A[:-3:-2]) 
 
As the step is a negative value, we are slicing from right to left.
Hence, “start” index should be larger or equal to the “end” index.
Default value for “start” is len(A)-1, i.e., 9 – 1 = 8
So, the expression A[:,-2,-2] is equivalent to A[8,-2,-2]
The element at index 8 is 9, and the element at index -2 is excluded.
So, it prints 9.
Key Takeaway:
Negative steps reverse traversal direction.
Negative stop indices count from the end of the array.
The stop index is exclusive (elements before it are included).

tranpose():
e.g. 
```
# shape (2, 2, 3)
# index 0 1 2 
arr = np.array([
                [[0, 1, 2],
                 [3, 4, 5]], 
                [[6, 7, 8], 
                 [9, 10, 11]]])
print(arr.transpose([2, 0 ,1])) 
# index shift 0 1 2
# 2->0 1->2 0->1
# output: we can locate the elements based on (2, 0, 1)
"""
[[[ 0  3]
  [ 6  9]]

 [[ 1  4]
  [ 7 10]]

 [[ 2  5]
  [ 8 11]]]
"""
```

reshape():
e.g.
```
arr = np.arange(24).reshape(-1, 3, 4) # or (2, 3, 4)
print(arr)
# output:
"""
[[[1, 2, 3, 4]
  [5, 6, 7, 8]
  [9, 10, 11, 12]]
[[13, 14, 15, 16]
 [17, 18, 19, 20]
  [21, 22, 23, 24]]]
"""
```

np.tile(): we dun need this if we use broadcasting
e.g. 
```
v = np.array([1, 0, 2])
vv = np.tile(v, (3, 1))
"""
[[1 0 2]
 [1 0 2]
 [1 0 2]]
"""
```

internal broadcasting:
e.g.
A shape 16x6x7
B shape 16x6
A*B
can't becuz it'll be 1x16x6 after prepending B throught internal broadcasting
C shape 5x6
D shape 7x7
can't but it can if D is 1x7
E shape 2x3
F shape 2,
can't but it can if E is 3x2 

find memory size of an array:
e.g.
```
print(A.size * A.itemsize)
```

find indices for non-zero elements:
e.g. 
```
F = np.array([0, 3, 0, 0, 1])
print(F.nonzero())
# output: (array([1, 4]),)
```

remark for randomness:
use np.random.random((z, x, y))

remark for full/ repeat function:
e.g. we need to build an array [7, 7, 7, 7]
```
L = np.full(4, 7) or L = np.repeat(7, 4)
```

inverse matrix:
we use np.linalg.inv(N) where N is a square matrix

2022F MT Q2aiii
```
print(B[:, 1, 3:0:-1])
# if there's a fixed int idx, e.g. '1', reduce the shape from (2, 3, 4) to (2, 4)

print(B[B%4==0]
# reshape from 3D to 1D

print(B.reshape(3, 4, 2))
# original array shape (2, 3, 4)
# flatten original array into 1D and remember the mapping of every element is by linearity but not dimensionality,i.e. reshape fills all dimensions sequentially, starting from the innermost (last axis).
```
